import * as fs from 'fs';
import { existsSync, mkdirSync } from 'fs';
import minimist from 'minimist';
import { parse as yamlParse } from 'yaml';

interface NestedStringObject {
  [key: string]: string | NestedStringObject;
}

interface Arguments {
  lib: string;
}

class DocumentationParser {
  lib: string;
  inputDirectory: string;
  outputDirectory: string;
  missingReferences: string[];
  copiedFiles: Record<string, string>;
  appRouterPath: string;

  constructor(lib: string) {
    this.lib = lib;
    this.inputDirectory = `./compodoc-docs/${this.lib}`;
    this.outputDirectory = `./projects/demo-app/src/assets/documentation/${this.lib}`;
    this.appRouterPath = `documentation/${this.lib}/`; // change with new routing pattern in 364
    this.missingReferences = [];
  }

  async parseDirectory(): Promise<void> {
    const documentationStructure = this.getDocumentationStructure();

    this.copiedFiles = await this.copyFilesToOutputDirAndGetRecord(
      this.inputDirectory,
      this.outputDirectory,
      documentationStructure
    );

    await this.replaceCrossReferences(this.copiedFiles).then(() => {
      console.log('Parsing has completed');
      if (this.missingReferences.length > 0) {
        console.log(
          'WARNING: Compodoc created references to the following files but they are not included in the documentation:'
        );
        console.log(this.missingReferences.join('\n'));
      }
    });
  }

  getDocumentationStructure() {
    const yamlLocation = `${this.outputDirectory}/documentation-structure.yaml`;
    let documentationStructure;
    try {
      const fileContents = fs.readFileSync(yamlLocation, 'utf8');
      documentationStructure = yamlParse(fileContents);
    } catch (err) {
      console.error(err);
    }
    return documentationStructure;
  }

  async copyFilesToOutputDirAndGetRecord(
    compodocDirectory: string,
    outputDirectory: string,
    config: NestedStringObject,
    copiedFiles: Record<string, string> = {}
  ): Promise<Record<string, string>> {
    const promises = Object.entries(config).map(
      async ([configKey, compodocPath]) => {
        if (typeof compodocPath === 'string') {
          if (!existsSync(outputDirectory)) {
            mkdirSync(outputDirectory, { recursive: true });
          }
          try {
            const source = `${compodocDirectory}/${compodocPath}`;
            const destination = `${outputDirectory}/${configKey}`;
            const text = await fs.promises.readFile(source, 'utf-8');
            // appPath corresponds to the way routing is set up in the site
            const appPath = `${this.appRouterPath}${destination.split(this.lib)[1]}`;
            const parsed = this.getParsedFile(text, appPath);
            copiedFiles[compodocPath] = destination;
            await fs.promises.writeFile(`${destination}.html`, parsed, 'utf8');
            console.log(appPath, 'copied successfully!');
          } catch (err) {
            console.error('Error copying file:', err);
          }
        } else {
          const updatedOutputDirectory = `${outputDirectory}/${configKey}`;
          await this.copyFilesToOutputDirAndGetRecord(
            compodocDirectory,
            updatedOutputDirectory,
            config[configKey] as NestedStringObject,
            copiedFiles
          );
        }
      }
    );
    await Promise.all(promises);
    return copiedFiles;
  }

  getParsedFile(text: string, path: string): string {
    const match = text.match(
      /<!-- START CONTENT -->([\s\S]*?)<!-- END CONTENT -->/
    );
    let content = match ? match[0] : '';
    content = content.replace(/(<script)(.|\n)*(<\/script>)/, '');
    // modifies href in tabs generated by compodoc to match routing pattern in site
    content = content.replace(/href="#/g, `href="${path}#`);
    return content;
  }

  async replaceCrossReferences(
    copiedFiles: Record<string, string>
  ): Promise<void> {
    const promises = Object.values(copiedFiles).map(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      async (outputPath) => {
        let text = await fs.promises.readFile(`${outputPath}.html`, 'utf-8');
        text = text.replace(
          /(href="..\/)(classes.*html|components.*html|directives.*html|interfaces.*html|injectables.*html)/g,
          (match, p1, p2) => this.replaceFileReference(p2, copiedFiles)
        );
        await fs.promises.writeFile(`${outputPath}.html`, text, 'utf8');
      }
    );
    await Promise.all(promises);
  }

  replaceFileReference(
    compodocFile: string,
    copiedFiles: Record<string, string>
  ): string {
    if (copiedFiles[compodocFile]) {
      const routerLink = copiedFiles[compodocFile]
        .replace('all/', '')
        .replace(this.outputDirectory, '')
        .replace('.html', '');
      // matches routing pattern used in app
      return `href="${this.appRouterPath}${routerLink}`;
    } else {
      if (!this.missingReferences.includes(compodocFile)) {
        this.missingReferences.push(compodocFile);
      }
    }
    return '';
  }
}

function getArgs(): Arguments {
  const args: Arguments = minimist(process.argv.slice(2));
  if (!args.lib) {
    console.error('Please provide a library name');
    process.exit(1);
  }
  return args;
}

const args = getArgs();
const documentationParser = new DocumentationParser(args.lib);
documentationParser.parseDirectory();
