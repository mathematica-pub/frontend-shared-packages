import * as fs from 'fs';
import { existsSync, mkdirSync } from 'fs';
import { parse as yamlParse } from 'yaml';

interface NestedStringObject {
  [key: string]: string | NestedStringObject;
}

class DocumentationParser {
  lib: string;
  inputDirectory: string;
  outputDirectory: string;
  missingKeys: string[];
  copiedFiles: Record<string, string>;
  routerPath: string;

  constructor(lib: string) {
    this.lib = lib;
    this.inputDirectory = `./compodoc-docs/${this.lib}`;
    this.outputDirectory = `./projects/demo-app/src/assets/documentation/${this.lib}`;
    this.routerPath = `documentation/${this.lib}`;
    this.missingKeys = [];
  }

  parseDirectory() {
    const documentationStructure = this.getDocumentationStructure();

    this.copiedFiles = this.copyFilesToOutputDirAndGetRecord(
      this.outputDirectory,
      this.inputDirectory,
      documentationStructure
    );

    if (this.missingKeys.length > 0) {
      console.log('MISSING FILES - LINKED IN DOCUMENTATION');
      console.log(this.missingKeys.join('\n'));
    }
  }

  getDocumentationStructure() {
    const yamlLocation = `${this.outputDirectory}/documentation-structure.yaml`;
    let documentationStructure;
    try {
      const fileContents = fs.readFileSync(yamlLocation, 'utf8');
      documentationStructure = yamlParse(fileContents);
    } catch (err) {
      console.error(err);
    }
    return documentationStructure;
  }

  copyFilesToOutputDirAndGetRecord(
    baseOutputDirPath,
    baseInputDirPath,
    config: NestedStringObject,
    copiedFiles = {}
  ) {
    Object.entries(config).forEach(([key, value]) => {
      if (typeof value === 'string') {
        if (!existsSync(baseOutputDirPath)) {
          mkdirSync(baseOutputDirPath, { recursive: true });
        }
        (async () => {
          try {
            const source = `${baseInputDirPath}/${value}`;
            const destination = `${baseOutputDirPath}/${key}`;
            const text = await fs.promises.readFile(source, 'utf-8');
            const pathForDoc = `${this.routerPath}${destination.split(this.lib)[1]}`;
            const parsed = this.getParsedFile(text, pathForDoc);
            fs.promises.writeFile(`${destination}.html`, parsed, 'utf8');
            console.log(pathForDoc, 'copied successfully!');
          } catch (err) {
            console.error('Error copying file:', err);
          }
        })();
      } else {
        const newPath = `${baseOutputDirPath}/${key}`;
        copiedFiles = this.copyFilesToOutputDirAndGetRecord(
          newPath,
          baseInputDirPath,
          config[key] as NestedStringObject,
          copiedFiles
        );
      }
    });
    return copiedFiles;
  }

  getParsedFile(text: string, path: string): string {
    const match = text.match(
      /<!-- START CONTENT -->([\s\S]*?)<!-- END CONTENT -->/
    );
    let content = match ? match[0] : '';
    content = content.replace(/(<script)(.|\n)*(<\/script>)/, '');
    // modifies href in tabs generated by compodoc to match routing pattern in site
    content = content.replace(/href="#/g, `href="${path}#`);
    content = content.replace(
      /(href="..\/)(classes.*html|components.*html|directives.*html|interfaces.*html|injectables.*html)/g,
      (match, p1, p2) => this.handleMatch([match, p1, p2])
    );
    return content;
  }

  handleMatch(match): string {
    if (this.copiedFiles[match[2]]) {
      const routerLink = this.copiedFiles[match[2]]
        .replace('all/', '')
        .replace(this.outputDirectory, '')
        .replace('.html', '');
      console.log(this.routerPath);
      return `href="documentation${routerLink}`;
    } else {
      if (!this.missingKeys.includes(match[2])) {
        this.missingKeys.push(match[2]);
      }
    }
    return '';
  }
}

// function getArgs() {
//   const args = process.argv.slice(2);
//   const argsObj = {};

//   for (let i = 0; i < args.length; i += 2) {
//     const key = args[i].replace('--', '');
//     const value = args[i + 1];
//     argsObj[key] = value;
//   }
//   return argsObj;
// }

// const args = getArgs();
const documentationParser = new DocumentationParser('viz-components');
documentationParser.parseDirectory();
