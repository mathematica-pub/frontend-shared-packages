import * as fs from 'fs';
import { existsSync, mkdirSync } from 'fs';
import minimist from 'minimist';
import { parse as yamlParse } from 'yaml';
import { deleteDirectoryContents } from './delete-directory-contents';

interface NestedStringObject {
  [key: string]: string | NestedStringObject;
}

interface Arguments {
  lib: string;
}

class DocumentationProcessor {
  lib: string;
  configPath: string;
  inputDirectory: string;
  outputDirectory: string;
  missingReferences: string[];
  appRouterPath: string;
  compodocFileTypes: string[];

  constructor(lib: string) {
    this.lib = lib;
    this.inputDirectory = `./compodoc/docs/${lib}`;
    this.configPath = `./projects/demo-app/src/assets/documentation/${lib}/documentation-structure.yaml`;
    this.outputDirectory = `./projects/demo-app/src/assets/documentation/${lib}/processed`;
    this.appRouterPath = `documentation/${lib}/`; // TODO: change with new routing pattern in 364 when 364 goes in
    this.missingReferences = [];
  }

  async parseDirectory(): Promise<void> {
    deleteDirectoryContents(this.outputDirectory);

    const documentationStructure = this.getDirectoryConfig();
    this.compodocFileTypes = this.getCompodocFileTypes(documentationStructure);

    const copiedFiles = await this.copyFilesToOutputDirAndGetRecord(
      this.inputDirectory,
      this.outputDirectory,
      documentationStructure
    );

    await this.replaceCrossReferences(copiedFiles).then(() => {
      console.log('Parsing has completed');
      if (this.missingReferences.length > 0) {
        console.log(
          'WARNING: Compodoc created references to the following files but they are not included in the documentation:'
        );
        console.log(this.missingReferences.join('\n'));
      }
    });
  }

  getDirectoryConfig(): NestedStringObject {
    let documentationStructure;
    try {
      const fileContents = fs.readFileSync(this.configPath, 'utf8');
      documentationStructure = yamlParse(fileContents);
    } catch (err) {
      console.error(err);
    }
    return documentationStructure;
  }

  getCompodocFileTypes(documentationStructure: NestedStringObject): string[] {
    const fileTypes = [];
    const traverse = (config: NestedStringObject) => {
      Object.values(config).forEach((value) => {
        if (typeof value === 'string') {
          const fileType = value.split('/')[0];
          if (!fileTypes.includes(fileType)) {
            fileTypes.push(fileType);
          }
        } else {
          traverse(value as NestedStringObject);
        }
      });
    };
    traverse(documentationStructure);
    return fileTypes;
  }

  async copyFilesToOutputDirAndGetRecord(
    compodocDirectory: string,
    outputDirectory: string,
    config: NestedStringObject,
    copiedFiles: Record<string, string> = {}
  ): Promise<Record<string, string>> {
    const promises = Object.entries(config).map(
      async ([configKey, compodocPath]) => {
        if (typeof compodocPath === 'string') {
          if (!existsSync(outputDirectory)) {
            mkdirSync(outputDirectory, { recursive: true });
          }
          try {
            const source = `${compodocDirectory}/${compodocPath}`;
            const destination = `${outputDirectory}/${configKey}`;
            const text = await fs.promises.readFile(source, 'utf-8');
            // appPath corresponds to the way routing is set up in the site
            const appPath = `${this.appRouterPath}${destination.split(this.lib)[1]}`;
            const parsed = this.getParsedFile(text, appPath);
            copiedFiles[compodocPath] = destination;
            await fs.promises.writeFile(`${destination}.html`, parsed, 'utf8');
            console.log(appPath, 'copied successfully!');
          } catch (err) {
            console.error('Error copying file:', err);
          }
        } else {
          const updatedOutputDirectory = `${outputDirectory}/${configKey}`;
          await this.copyFilesToOutputDirAndGetRecord(
            compodocDirectory,
            updatedOutputDirectory,
            config[configKey] as NestedStringObject,
            copiedFiles
          );
        }
      }
    );
    await Promise.all(promises);
    return copiedFiles;
  }

  getParsedFile(text: string, path: string): string {
    const match = text.match(
      /<!-- START CONTENT -->([\s\S]*?)<!-- END CONTENT -->/
    );
    let content = match ? match[0] : '';
    content = content.replace(/(<script)(.|\n)*(<\/script>)/, '');
    // modifies href in tabs generated by compodoc to match routing pattern in site
    content = content.replace(/href="#/g, `href="${path}#`);
    return content;
  }

  async replaceCrossReferences(
    copiedFiles: Record<string, string>
  ): Promise<void> {
    const promises = Object.values(copiedFiles).map(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      async (outputPath) => {
        let text = await fs.promises.readFile(`${outputPath}.html`, 'utf-8');
        const files = this.compodocFileTypes.join('.*html|') + '.*html';
        const regex = new RegExp(`(href="../)(${files})`, 'g');
        text = text.replace(regex, (match, p1, p2) =>
          this.replaceFileReference(p2, copiedFiles)
        );
        await fs.promises.writeFile(`${outputPath}.html`, text, 'utf8');
      }
    );
    await Promise.all(promises);
  }

  replaceFileReference(
    compodocFileReference: string,
    copiedFiles: Record<string, string>
  ): string {
    if (copiedFiles[compodocFileReference]) {
      const routerLink = copiedFiles[compodocFileReference].replace(
        this.outputDirectory,
        ''
      );
      // matches routing pattern used in app, cut off leading / in routerLink to avoid //
      return `href="${this.appRouterPath}${routerLink.substring(1)}`;
    } else {
      if (!this.missingReferences.includes(compodocFileReference)) {
        this.missingReferences.push(compodocFileReference);
      }
    }
    return '';
  }
}

function getArgs(): Arguments {
  const args: Arguments = minimist(process.argv.slice(2));
  if (!args.lib) {
    console.error('Please provide a library name');
    process.exit(1);
  }
  return args;
}

const args = getArgs();
const documentationParser = new DocumentationProcessor(args.lib);
documentationParser.parseDirectory();
